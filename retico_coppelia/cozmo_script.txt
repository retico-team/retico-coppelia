import time
import threading
import numpy as np

# Cozmo radi
WHEELBASE_RADIUS = 0.0729
FRONT_WHEEL_RADIUS = 0.0495
BACK_WHEEL_RADIUS = 0.0375
BACK_WHEEL_SCALAR = 1.32  # TODO: Recalculate this

def sysCall_init():
    # Init scene object handles
    self.sim = require('sim')
    self.cozmo = self.sim.getObject('/cozmo')
    self.joints = {}
    for name in ['left_front', 'left_back', 'right_front', 'right_back']:
        self.joints[name] = self.sim.getObject('/cozmo/' + name + '_joint')

    # Flags
    self.moving = False

    # Cozmo target variables
    self.target_radians = 0
    self.target_speed = 0

    # variable trackers
    self.cum_angle = 0
    self.prev_angle = self.sim.getObjectOrientation(self.cozmo)[2]

def sysCall_thread():
    # Put your main code here
    pass

def sysCall_sensing():
    curr_angle = self.sim.getObjectOrientation(self.cozmo)[2]

    # Update tracker variables
    angle_diff = curr_angle - self.prev_angle
    if angle_diff > np.pi:
        angle_diff -= 2 * np.pi
    elif angle_diff < -np.pi:
        angle_diff += 2 * np.pi

    self.cum_angle += angle_diff
    self.prev_angle = curr_angle
    err = self.target_radians - self.cum_angle

    if abs(err) < np.radians(1):  # less than 0.017 radians
        # Reset values and trackers
        set_wheel_velocity(0)
        self.target_radians = 0
        self.target_speed = 0
        self.moving = False
        self.cum_angle = 0
        self.prev_angle = self.sim.getObjectOrientation(self.cozmo)[2]
        print("Target reached.")
    elif abs(err) < 1:  # less than 1 radians
        self.target_speed = min(np.log(abs(err)) + 2 * np.e, self.target_speed)

    set_wheel_velocity(self.target_speed)

def set_wheel_velocity(speed: float, spin=True):
    if spin:
        vel_front = 2 * (speed * WHEELBASE_RADIUS) / FRONT_WHEEL_RADIUS
        vel_back = 2 * (speed * WHEELBASE_RADIUS) / BACK_WHEEL_RADIUS

        if self.target_radians > 0:
            self.sim.setJointTargetVelocity(self.joints['left_front'], vel_front)
            self.sim.setJointTargetVelocity(self.joints['left_back'], vel_back)
            self.sim.setJointTargetVelocity(self.joints['right_front'], -vel_front)
            self.sim.setJointTargetVelocity(self.joints['right_back'], -vel_back)
        else:
            self.sim.setJointTargetVelocity(self.joints['left_front'], -vel_front)
            self.sim.setJointTargetVelocity(self.joints['left_back'], -vel_back)
            self.sim.setJointTargetVelocity(self.joints['right_front'], vel_front)
            self.sim.setJointTargetVelocity(self.joints['right_back'], vel_back)
    else:
        self.sim.setJointTargetVelocity(self.joints['left_front'], vel_front)
        self.sim.setJointTargetVelocity(self.joints['left_back'], vel_back)
        self.sim.setJointTargetVelocity(self.joints['right_front'], vel_front)
        self.sim.setJointTargetVelocity(self.joints['right_back'], vel_back)


def turn_in_place(radians, rads):
    if radians == 0: return

    radians *= -1  # Flips polarity to match Cozmo's orientation scheme

    self.target_radians = radians
    self.target_speed = rads
    self.moving = True

def is_moving():
    return self.moving

# See the user manual or the available code snippets for additional callback functions and details
